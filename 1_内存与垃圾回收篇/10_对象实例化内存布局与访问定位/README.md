---
title: 10-对象实例化内存布局与访问定位
tags:
notebook: 宋红康-JVM
---

### 1. 对象实例化

#### 1.1 面试题

- 对象在 JVM 中是怎么存储的？
- 对象头信息里面有哪些东西？
- Java 对象头有什么？

从对象创建的方式和步骤开始说

<img src="https://tva2.sinaimg.cn/large/006JhGcily1gwj0og0529j30uu0gf79i.jpg" alt="image-20200709095356247" width="90%">

#### 1.2 对象创建方式

- `new：最常见的方式、单例类中调用getInstance的静态类方法，XXXBuilder、XXXFactory的静态方法`
- `Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，权限必须是public`
- `Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器，权限没有要求`
- `使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法`
- `使用反序列化：从文件中，从网络中获取一个对象的二进制流`
- `第三方库 Objenesis`

#### 1.3 创建对象的步骤

##### 1.3.1 判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 key 进行查找对应的 .class 文件，如果没有找到文件，则抛出 ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的 Class 类对象。

##### 1.3.2 为对象分配内存

首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小

- 如果内存规整：`指针碰撞`

- 如果内存不规整
  - 虚拟机需要维护一个列表
  - `空闲列表分配`

如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。

意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。`如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式`。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。

如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是`空闲列表`来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 "空闲列表（Free List）"。

`选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定`。

##### 1.3.3 处理并发问题

- `采用 CAS 配上失败重试保证更新的原子性`
- 每个线程预先分配 TLAB - 通过设置 `-XX:+UseTLAB` 参数来设置（区域加锁机制）
  - 在 Eden 区给每个线程分配一块区域

##### 1.3.4 初始化分配到的内存

给对象属性赋值的操作

- 属性的默认初始化
- 显示初始化
- 代码块中的初始化
- 构造器初始化

- 所有属性设置默认值，保证对象实例字段在不赋值可以直接使用

##### 1.3.5 设置对象的对象头

`将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现`。

##### 1.3.6 执行 init 方法进行初始化

在 Java 程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量

因此一般来说（由字节码中跟随 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。

#### 1.4 对象实例化的过程

- 加载类元信息
- 为对象分配内存
- 处理并发问题
- 属性的默认初始化（零值初始化）
- 设置对象头信息
- 属性的显示初始化、代码块中初始化、构造器中初始化

### 2. 对象内存布局

<img src="https://tvax1.sinaimg.cn/large/006JhGcily1gwj3hsd5dkj313a0hxdmt.jpg" alt="image-20200709151033237" width="85%">

#### 2.1 对象头

对象头包含了两部分，分别是 `运行时元数据（Mark Word）`和 `类型指针`

> `如果是数组，还需要记录数组的长度`

##### 2.1.1 运行时元数据

- `哈希值（HashCode）`
- `GC 分代年龄`
- `锁状态标志`
- `线程持有的锁`
- `偏向线程 ID`
- `偏向时间戳`

##### 2.1.2 类型指针

`指向类元数据 InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息`

#### 2.2 实例数据（Instance Data）

##### 2.2.1 说明

它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)相同宽度的字段总是被分配在一起

##### 2.2.2 规则

- 相同宽度的字段总是被分配在一起
- 父类中定义的变量会出现在子类之前
- 如果 CompactFields 参数为 true(默认为 true):子类的窄变量可能插入到父类变量的空隙

#### 2.3 对齐填充（Padding）

##### 2.3.1 说明

不是必须的，也没有特别的含义，仅仅起到占位符的作用

#### 2.4 小结

<img src="https://tva2.sinaimg.cn/large/006JhGcigy1gwj863uetoj30x00h9k3v.jpg" alt="image-20200709152801713" width="85%">

### 3. 对象的访问定位

JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？

<img src="https://tvax2.sinaimg.cn/large/006JhGcily1gwj9lsbwnwj30hj09mwft.jpg" alt="image-20200709164149920" width="70%">

#### 3.1 对象访问的两种方式

##### 3.1.1 句柄访问

句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池

<img src="https://tva4.sinaimg.cn/large/006JhGcigy1gwj9n5gsyij30sr0gfjz1.jpg" alt="image-20200709164342002" width="80%">

**优点**

reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改

##### 3.1.2 直接指针（HotSpot 采用）

直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据

<img src="https://tva4.sinaimg.cn/large/006JhGcigy1gwj9oaebz3j30re0gedmz.jpg" alt="image-20200709164350466" width="85%">
